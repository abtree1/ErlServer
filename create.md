本文件记录整个项目创建过程, rebar 可通过github获取

1. 通过rebar创建项目 ./rebar create-app appid=erl_server

2. 编写makefile来启动项目

3. 为了方便日志记录,尝试使用sasl，但sasl需要控制台命令rb才能处理日志，极为不方便,因此引入lager库

   lager库需要在erl_server.config中配置，并且在启动时引入该config
   		  需要在rebar.config中设置{erl_opts, [{parse_transform, lager_transform}]}
   		  最后lager:start()
	在rebar.config中加入lager及其依赖库的依赖,同时在编译时./rebar get-deps编译依赖库

4.读取配置文件，并转换为record:
  1,配置项保存格式[{key, value, value,...},{key, value, value,...}...]
  2,不同的配置表保存在ets里(已废弃使用ets，改用文件存储)
  	key = 表名（term）
  	value = 1的配置项
  3,每个配置项对应一个与表明相同的record，在读取的时候会自动转换为相应的record
  	record信息保存在config.hrl中，make config || make start，该文件自动生成
  4,放弃ets表，将数据存入config_data.hrl中
    
    config文件必须满足的格式：
        由于erlang语言的特性，config文件最好不使用大写字母,至少首字母不能大写
        config文件必须以".conf"结尾
        config文件内容如模版，值得注意的是，关键字符包括 TAB(\t) 用于项之间分割，因此，配置内容里面不能有TAB符号，换行符(\r\n or \n)，用于列之间分割，因此，配置中不能出现，冒号(:)，用于title与其类型分割，在title中不能重复出现，类型目前只有string，integer，float三种。
        另外，第一列标示符，＃号，表示该列有效，不带表示该列无效，title中的flag可有可无或是其它占位符，但其后的TAB(\t)不可省略。

5.重新生成的hrl文件需要重新编译，这里通过修改makefile，增加start选项，使server在运行之前先编译config

6.dirty words 为了加快其遍历速度，将其作为特殊配置文件处理，采用字典树。其配置文件dirtywords.filter，换行符可以是"\r\n" 或 "\n"

7.erl_counter 用于记录游戏运行时数据，同时处理延时任务，运行时数据用mnesia存储，timertask延时任务，有两种解决方案，其一为绑定在各个线程上，让各个线程自己处理自己的延时任务，这样异步性较好，但每个线程都需要处理自己的handle info消息，其二为用一个统一的线程来处理所有的timertask任务。
    timertask数据恢复，通过MFA完成的timertask可以数据恢复

8.数据库操作至少需要满足两个要求,其一，将数据导入到内存中，自动转换为相应的record，其二，支持sql语句操作,同时，数据库的创建过程应该被记录
  
  特殊：由于系统用了许多erl_counter，增加key_words文件，记录系统使用的key，在其它地方，不可重复使用

  数据库操作是绑定到每个线程自己执行自己的操作，还是集中起来在一个统一的线程处理呢？考虑查询在各自线程自己执行，写入在统一线程执行,(包括增加，删除，修改)，由于emysql已经有线程管理，所以此处不会产生脏数据，将写入操作放入单独线程处理，只是提高并发，以增强处理玩家逻辑的效率,db.sql配置文件由sql构成，因此，写sql为必须能力

9.tcp erl_conn 每个玩家依然维护两个线程，一个socket conn线程，一个逻辑线程

10.虽然在protocol这块，我打算引入外部库，不过，我还是先自己实现一下，毕竟是练手项目。protocol由配置文件解析,参考google protocol buffer，但google proto buff的消息内容是和协议分开的。此处也要考虑，外部语言的不确定性。
    
    目前实现的协议解析版本要求protocol.pro中配置的解析格式，其中协议名后面的数字为协议id，可不配，如果不配，会自动分配。protocol.pro文件需要对应的client也能解析，pcontrollers.pro为协议的处理函数配置，只需本server解析，与外部处理无关。

11.封装record操作，需要导出record的结构，在此，由于动态导出record结构比较复杂，此处导入parse_trans库
    
12.数据存储，实时存储性能太低，但考虑实时创建，定时更新。玩家所有数据更新，考虑存储过程,存储过程太过复杂，且性能太低，而且SQL不支持条件判断语句，中和考虑，需要给数据加状态

13.对于数据库数据的存储，每个用户逻辑线程单独存储其数据是毋庸置疑的，而存储的许多细致问题，比如，是采用list记录record的uuid和状态，每个记录单独记录好呢，还是list直接记录record的uuid，record本身，和状态。目前，朋友的项目采用了前者，而我的项目采用了后者，至于为什么这么处理，到没有特别原因。

14.联盟，可以看作特殊的player，但此处我打算新建联盟线程，需要考虑包括，聊天，存储，遍历，排行等诸多问题.

15.数据存储包括两种方案。其一为将原数据删除，重新创建；其二为更新原数据。在更新时最大的麻烦为，当数据首次创建时，需要走创建流程

16.综合考虑，排名数据单独存储比较合理，但更新不需实时的。

17.地图，地图实现四边形地图和六边形地图

18.六边形地图以每10 * 10个为一组，格子按等级分为九种不同的等级，每个等级包含1中到多种类型，在100个格子中，各种等级，以及每种等级的type分布，由配置文件觉定，大致分布满足这样的配置

      level   amount  (由于type数为3，故不能被3整除需要调整)
      1       20  -> 2
      2       18
      3       16  -> 1
      4       13  -> 1
      5       11  -> 2
      6       9
      7       7
      8       4
      9       2

19.由于地图格子数量太大，此处分组分段处理，每100个为1组，10000个为1段